#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <cmath>
#include "raylib.h"

// Определение констант
const int rows = 13;
const int cols = 13;
const int cellSize = 40;
const int otstup = 5;

// 0 - 99 ландшафт
// 1 - невозможно пройти 
// 2 - спавнер
// 3 - база
// 100 - 199 - пулемётная башня
// 200 - 299 - ракетная башня

const int matrix1[rows][cols] =
{
    {1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1},
    {1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1},
    {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1},
    {1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1},
    {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1},
    {1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1}
};

// Впереди объявляем класс Enemy
class Enemy;

// Класс Турелей
class Turret {
public:
    int x, y;
    int damage = 1;
    int attackRadius = 2;
    float atkspeed = 0.5f; // Задержка между атаками
    float attackCooldown = 0.0f; // Время, прошедшее с последней атаки

    Turret(int posX, int posY) : x(posX), y(posY) {}

    void draw() const {
        DrawRectangle(static_cast<int>(x * (cellSize + otstup) + cellSize / 4),
            static_cast<int>(y * (cellSize + otstup) + cellSize / 4),
            static_cast<int>(cellSize / 2),
            static_cast<int>(cellSize / 2), YELLOW);
    }

    void attack(std::vector<Enemy>& enemies, float deltaTime);
};

// Структура для узлов A*
struct Node {
    int x, y;
    int g, h; // g - cost от старта, h - heuristic до цели
    Node* parent;

    int f() const { return g + h; } // общая стоимость
    bool operator>(const Node& other) const { return f() > other.f(); }
};

// Если клетка в диапазоне массива
bool isValid(int x, int y) {
    return x >= 0 && x < cols&& y >= 0 && y < rows;
}

// Эвристика Манхэттена
int heuristic(int x1, int y1, int x2, int y2) {
    return abs(x1 - x2) + abs(y1 - y2);
}

// Алгоритм A*
bool aStar(int startX, int startY, int endX, int endY, const int(&matrix)[rows][cols], std::vector<Node>& path) {
    std::priority_queue<Node, std::vector<Node>, std::greater<Node>> openSet;
    std::vector<std::vector<bool>> closedSet(rows, std::vector<bool>(cols, false));

    Node start{ startX, startY, 0, heuristic(startX, startY, endX, endY), nullptr };
    openSet.push(start);

    while (!openSet.empty()) {
        Node current = openSet.top();
        openSet.pop();

        if (current.x == endX && current.y == endY) {
            Node* node = &current;
            while (node != nullptr) {
                path.push_back(*node);
                node = node->parent;
            }
            std::reverse(path.begin(), path.end());
            return true; // Путь найден
        }

        closedSet[current.y][current.x] = true;

        std::vector<int> directions = { -1, 0, 1, 0, 0, -1, 0, 1 }; // (dx, dy) для влево, вверх, вправо, вниз

        for (size_t i = 0; i < directions.size(); i += 2) {
            int newX = current.x + directions[i];
            int newY = current.y + directions[i + 1];

            if (isValid(newX, newY) && !closedSet[newY][newX] && matrix[newY][newX] != 1) {
                Node neighbor{ newX, newY, current.g + 1, heuristic(newX, newY, endX, endY), new Node(current) };
                openSet.push(neighbor);
            }
        }
    }
    return false; // Путь не найден
}

// Класс врага
class Enemy {
public:
    int x, y;
    int speed = 1;
    int health = 5;
    bool alive = true; // Флаг живой/мертвой

    std::vector<Node> path;
    size_t pathIndex = 0;

    // Время задержки в секундах между перемещениями врага
    float moveDelay = 0.8f; // 0.8 секунды
    float elapsedTime = 0.0f; // Время, прошедшее с последнего обновления

    Enemy(int startX, int startY, const std::vector<Node>& foundPath)
        : x(startX), y(startY), path(foundPath) {}

    void update(float deltaTime) {
        if (!alive) return; // Если враг мертв, не обновляем

        elapsedTime += deltaTime; // Увеличиваем время задержки

        if (elapsedTime >= moveDelay && pathIndex < path.size()) {
            Node& nextNode = path[pathIndex];

            // Движение врага по всему пути
            if (x < nextNode.x) {
                x += speed;
            }
            else if (x > nextNode.x) {
                x -= speed;
            }
            else if (y < nextNode.y) {
                y += speed;
            }
            else if (y > nextNode.y) {
                y -= speed;
            }

            // Если враг достиг следующей клетки
            if (x == nextNode.x && y == nextNode.y) {
                pathIndex++;
            }

            elapsedTime = 0;
        }
    }

    bool isAtBase() {
        return (pathIndex >= path.size()) || (x == path.back().x && y == path.back().y);
    }
};

// Реализация метода attack с учётом задержки
void Turret::attack(std::vector<Enemy>& enemies, float deltaTime) {
    attackCooldown -= deltaTime; // Уменьшаем таймер

    if (attackCooldown <= 0) { // Если прошла задержка
        for (auto& enemy : enemies) {
            int distance = abs(enemy.x - x) + abs(enemy.y - y);
            if (distance <= attackRadius) {
                enemy.health -= damage;
                if (enemy.health <= 0) {
                    enemy.alive = false; // Убиваем врага
                }
            }
        }
        attackCooldown = atkspeed; // Сброс таймера
    }
}

// Функция для отрисовки матрицы
void DrawMatrix(const int(&matrix)[rows][cols]) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            switch (matrix[i][j]) {
            case 1:
                DrawRectangle(static_cast<int>(j * (cellSize + otstup)),
                    static_cast<int>(i * (cellSize + otstup)),
                    static_cast<int>(cellSize),
                    static_cast<int>(cellSize), DARKBLUE);
                break;
            case 2:
                DrawRectangle(static_cast<int>(j * (cellSize + otstup)),
                    static_cast<int>(i * (cellSize + otstup)),
                    static_cast<int>(cellSize),
                    static_cast<int>(cellSize), RED);
                break;
            case 3:
                DrawRectangle(static_cast<int>(j * (cellSize + otstup)),
                    static_cast<int>(i * (cellSize + otstup)),
                    static_cast<int>(cellSize),
                    static_cast<int>(cellSize), GREEN);
                break;
            default:
                DrawRectangle(static_cast<int>(j * (cellSize + otstup)),
                    static_cast<int>(i * (cellSize + otstup)),
                    static_cast<int>(cellSize),
                    static_cast<int>(cellSize), WHITE);
                break;
            }
        }
    }
}

int main() {
    InitWindow(800, 600, "Game");
    SetTargetFPS(60);

    // Начальные и конечные координаты
    int startX = -1, startY = -1, endX = -1, endY = -1;

    // Поиск координат для начала (2) и конца (3)
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (matrix1[i][j] == 2) {
                startX = j;
                startY = i;
            }
            if (matrix1[i][j] == 3) {
                endX = j;
                endY = i;
            }
        }
    }

    // Проверка, найден ли старт и финиш
    if (startX == -1 || startY == -1 || endX == -1 || endY == -1) {
        std::cerr << "no start!" << std::endl;
        CloseWindow();
        return -1;
    }

    std::vector<Node> path; // Вектор для хранения найденного пути
    bool foundPath = aStar(startX, startY, endX, endY, matrix1, path); // Запуск A* от (startX, startY) до (endX, endY)
    std::vector<Enemy> enemies; // Вектор для хранения врагов
    enemies.emplace_back(startX, startY, path); // Создаем врага на стартовой позиции

    std::vector<Turret> turrets; // Вектор для хранения турелей
    const int maxTurrets = 4; // Максимальное количество турелей

    if (foundPath) {
        std::cout << "find!" << std::endl;
    }
    else {
        std::cout << "nope." << std::endl;
    }

    while (!WindowShouldClose()) {
        float deltaTime = GetFrameTime(); // Время, прошедшее с последнего кадра

        for (auto& turret : turrets) {
            turret.attack(enemies, deltaTime); // Турели атакуют врагов
        }

        for (size_t i = 0; i < enemies.size(); ) {
            if (enemies[i].alive) {
                enemies[i].update(deltaTime); // Обновить позицию живого врага
                i++; // Увеличить индекс только для живых врагов
            }
            else {
                enemies.erase(enemies.begin() + i); // Удалить мертвого врага
            }
        }

        // Обработка ввода для установки турелей
        if (IsMouseButtonPressed(MOUSE_RIGHT_BUTTON)) {
            Vector2 mousePos = GetMousePosition();
            int gridX = static_cast<int>(mousePos.x / (cellSize + otstup));
            int gridY = static_cast<int>(mousePos.y / (cellSize + otstup));

            // Проверка на количество турелей и что клик был в границах и на клетке 1
            if (turrets.size() < maxTurrets && isValid(gridX, gridY) && matrix1[gridY][gridX] == 1) {
                turrets.emplace_back(gridX, gridY);
            }
        }

        BeginDrawing();
        ClearBackground(DARKGRAY);
        DrawMatrix(matrix1);

        // Рисуем найденный путь
        float offset = cellSize / 4; // смещение для центрирования
        for (const auto& node : path) {
            DrawRectangle(static_cast<int>(node.x * (cellSize + otstup) + offset),
                static_cast<int>(node.y * (cellSize + otstup) + offset),
                static_cast<int>(cellSize / 2),
                static_cast<int>(cellSize / 2),
                GRAY);
        }

        // Рисуем турели
        for (const auto& turret : turrets) {
            turret.draw();
        }

        // Рисуем врагов
        for (const auto& enemy : enemies) {
            if (enemy.alive) { // Проверяем, жив ли враг
                float offset1 = cellSize / 2;
                DrawCircle(static_cast<int>(enemy.x * (cellSize + otstup) + offset1),
                    static_cast<int>(enemy.y * (cellSize + otstup) + offset1),
                    static_cast<int>(cellSize / 4),
                    MAGENTA);
            }
        }

        EndDrawing();
    }

    CloseWindow();
    return 0;
}
