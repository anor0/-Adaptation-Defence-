#include <iostream>
#include "raylib.h"
#include <vector>
#include <string>
#include <queue> // Для работы с очередями
#include <algorithm> // Для std::min

// 0 - 99 ландшафт
// 1 - невозможно пройти 
// 2 - спавнер
// 3 - база
// 100 - 199 - пулемётная башня
// 200 - 299 - ракетная башня
// 12 _ - клетки повышеной стоимости
const int rows = 13;
const int cols = 13;
const int cellSize = 40;
const int otstup = 5;
int i, j;
int cost = 0;
// уровни
const int matrix1[rows][cols] = {
    {1,1,1,1,1,1,2,1,1,1,1,1,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,1},
    {1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1},
    {1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1},
    {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1},
    {1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1},
    {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1},
    {1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1}
};
int matrix2[rows][cols] = {

    {1,1,1,1,1,1,2,1,1,1,1,1,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,1},
    {1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1},
    {1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1},
    {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1},
    {1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1},
    {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1},
    {1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1}
};


void DrawMatrix(const int(&matrix)[rows][cols]) {
    for (i = 0; i < rows; i++) {
        for (j = 0; j < cols; j++) {
            switch (matrix[i][j]) {
            case 1:
                DrawRectangle(j * (cellSize+otstup), i * (cellSize + otstup), cellSize, cellSize, DARKBLUE);
                break;
            case 2:
                DrawRectangle(j * (cellSize + otstup), i * (cellSize + otstup), cellSize, cellSize, RED);
                break;
            case 3:
                DrawRectangle(j * (cellSize + otstup), i * (cellSize + otstup), cellSize, cellSize, GREEN);
                break;
            default:
                DrawRectangle(j * (cellSize + otstup), i * (cellSize + otstup), cellSize, cellSize, WHITE);
                break;
            }
        }
    }
}


// враги

struct Enemy {
    int x;
    int y;
    const int speed = 1; // скорость движения
    bool alive = true;
    int hp = 5;
};

std::vector<Enemy> enemies;

void SpawnEnemy(const int(&matrix)[rows][cols]) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (matrix[i][j] == 2) { // Если клетка - спавнер
                enemies.push_back({ j * (cellSize + otstup), i * (cellSize + otstup)}); // Спавним врага на спавнере
            }
        }
    }
}




// Структура для хранения координат
struct Node {
    int x, y;
    int cost; // Суммарная стоимость пути
    int priority; // Приоритет для A*, суммарная стоимость
};

// Функция для эвристической оценки 
int Heuristic(int x, int y, int targetX, int targetY) {
    return std::abs(x - targetX) + std::abs(y - targetY);
}

// Функция для поиска пути
std::vector<Node> AStar(const int(&matrix)[rows][cols], Node start, Node target) {
    // Набор открытых и закрытых узлов
    std::priority_queue<Node> openSet;
    std::vector<std::vector<bool>> closedSet(rows, std::vector<bool>(cols, false));
    openSet.push(start);

    while (!openSet.empty()) {
        Node current = openSet.top();
        openSet.pop();

        if (current.x == target.x && current.y == target.y) {
            // Достигли цели
            return {}; 
        }

        closedSet[current.y][current.x] = true;

        // Проверка соседей
        const int directions[4][2] = { {1,0}, {0,1}, {-1,0}, {0,-1} }; // Вправо, вниз, влево, вверх
        for (const auto& direction : directions) {
            int newX = current.x + direction[0];
            int newY = current.y + direction[1];

            if (newX >= 0 && newX < cols && newY >= 0 && newY < rows) {
                if (matrix[newY][newX] != 1 && !closedSet[newY][newX]) { // Если клетка не проходима
                    Node neighbor = { newX, newY, current.cost + 1, current.cost + 1 + Heuristic(newX, newY, target.x, target.y) };
                    openSet.push(neighbor);
                }
            }
        }
    }
    return {}; // Если путь не найден
}

void MoveEnemies(const int(&matrix)[rows][cols]) {
    for (auto& enemy : enemies) {
        if (enemy.alive) {
            Node start{ enemy.x / (cellSize + 5), enemy.y / (cellSize + 5) };
            Node target{ -1, -1 }; // Позиция базы

            // Поиск клетки, где находится база (3)
            for (int i = 0; i < rows; ++i) {
                for (int j = 0; j < cols; ++j) {
                    if (matrix[i][j] == 3) {
                        target.x = j;
                        target.y = i;
                    }
                }
            }

            if (target.x != -1 && target.y != -1) {
                // Найти путь используя A*
                std::vector<Node> path = AStar(matrix, start, target);
                // Здесь мы должны реализовать перемещение врага по path
                // На примере, если путь найден, переместим врага на следующий узел
                if (!path.empty()) {
                    enemy.x = path[0].x * (cellSize + 5);
                    enemy.y = path[0].y * (cellSize + 5);
                }
            }
        }
    }
}


// игра
int main() {
    InitWindow(800, 600, "Game");
    SetTargetFPS(60);
    
    while (!WindowShouldClose()) {

        SpawnEnemy(matrix1);
        MoveEnemies(matrix1);

        BeginDrawing();
        ClearBackground(DARKGRAY);
        DrawMatrix(matrix1);
        
        

        
       
        
        EndDrawing();
    }

    CloseWindow();
    return 0;
}
